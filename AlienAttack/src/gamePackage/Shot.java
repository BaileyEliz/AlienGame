package gamePackage;

import java.util.ArrayList;

import javafx.animation.Transition;
import javafx.animation.TranslateTransition;
import javafx.scene.Scene;
import javafx.util.Duration;

/*
 * The shot looks like a fire emoji and is managed by
 * a shot manager, but can be created two different ways.
 */
public class Shot extends Sprite {

    private MouseCoords _mouse;
    private Scene _scene;

    //the constructor for a shot generated by the press of
    //a spacebar
    public Shot(MouseCoords mouse, Scene scene) {
        setX(Constants.ORIGIN);
        setY(Constants.ORIGIN);
        _mouse = mouse;
        setupShot(scene);
        initializeShot();
    }

    //the constructor for a shot generated by a cheat code 
    //or the explosion of a star
    public Shot(double x, double y, int index, Scene scene, int indicator){
        setX(x);
        setY(y);
        setupShot(scene);
        initializeExplosion(index, indicator);
    }

    public void setupShot(Scene scene){
        setWidth(Constants.SHOT_WIDTH);
        setHeight(Constants.SHOT_HEIGHT);
        setFileName(Constants.SHOT_IMAGE);
        initializeImage();
        _scene = scene;
    }

    //for shots created with the space bar, trigonometry is
    //used to find the angle that the user's mouse was to the
    //origin and to extend the shot past the user's click to
    //the edge of the screen.
    private void initializeShot(){

        double miniHypot;
        double largeHypot;
        double edgePoint;
        double distance;
        TranslateTransition translate;

        //four different quadrants of the screen mean that the angles 
        //must be processed four different ways, and that the 
        //transitions must be added to the shots in four different ways.
        //the algebra is different in each if statement; the first is 
        //commented as an example
        
        //if the click was on the left of Earth
        if(_mouse.getXCoord() <= Constants.ORIGIN){
            //if the click was above Earth
            if(_mouse.getYCoord() <= Constants.ORIGIN){
                //get the distance of the mini hypoteneuse made with the click
                miniHypot = Math.sqrt(Math.pow((Constants.ORIGIN - _mouse.getXCoord()), 2)
                                      + Math.pow((Constants.ORIGIN - _mouse.getYCoord()), 2));
                //extend that distance to the edge of the screen
                largeHypot = ((Constants.ORIGIN/(Constants.ORIGIN - _mouse.getXCoord())) * miniHypot);
                //calculate the y point based on that distance
                edgePoint = Math.sqrt(Math.pow(largeHypot, 2) - Math.pow(Constants.ORIGIN, 2));
                
                //get the distance between the new point and the origin
                distance = (Math.sqrt(Math.pow(-Constants.ORIGIN, 2) + Math.pow((-edgePoint), 2)));

                //create a translation with a constant rate for almost all angles
                translate =  
                        new TranslateTransition(Duration.millis(Constants.SHOT_RATE_CONSTANT * ((distance % Constants.SHOT_RATE_UPPER_BOUND) + Constants.SHOT_RATE_LOWER_BOUND))); 
                //send the shot all the way to the left
                translate.setToX(-Constants.ORIGIN); 
                //send the shot up to the right point
                translate.setToY(-edgePoint);
            }
            else{
                miniHypot = Math.sqrt(Math.pow((Constants.ORIGIN - _mouse.getXCoord()), 2)
                                      + Math.pow((_mouse.getYCoord() - Constants.ORIGIN), 2));
                largeHypot = ((Constants.ORIGIN/(Constants.ORIGIN - _mouse.getXCoord())) * miniHypot);
                edgePoint = Math.sqrt(Math.pow(largeHypot, 2) - Math.pow(Constants.ORIGIN, 2));

                distance = (Math.sqrt(Math.pow(-Constants.ORIGIN, 2) + Math.pow((edgePoint), 2)));

                translate =  
                        new TranslateTransition(Duration.millis(Constants.SHOT_RATE_CONSTANT * ((distance % Constants.SHOT_RATE_UPPER_BOUND) + Constants.SHOT_RATE_LOWER_BOUND))); 
                translate.setToX(-Constants.ORIGIN); 
                translate.setToY(edgePoint);
            }
        }
        else{
            if(_mouse.getYCoord() <= Constants.ORIGIN){
                miniHypot = Math.sqrt(Math.pow((_mouse.getXCoord() - Constants.ORIGIN), 2)
                                      + Math.pow((Constants.ORIGIN - _mouse.getYCoord()), 2));
                largeHypot = (((_scene.getWidth() - Constants.ORIGIN)/(_mouse.getXCoord() - Constants.ORIGIN)) * miniHypot);
                edgePoint = Math.sqrt(Math.pow(largeHypot, 2) - Math.pow((_scene.getWidth() - Constants.ORIGIN), 2));

                distance = (Math.sqrt(Math.pow((_scene.getWidth() - Constants.ORIGIN), 2) + Math.pow((-edgePoint), 2)));

                translate =  
                        new TranslateTransition(Duration.millis(Constants.SHOT_RATE_CONSTANT * ((distance % Constants.SHOT_RATE_UPPER_BOUND) + Constants.SHOT_RATE_LOWER_BOUND)));  
                translate.setToX(_scene.getWidth() - Constants.ORIGIN); 
                translate.setToY(-edgePoint);
            }
            else{
                miniHypot = Math.sqrt(Math.pow((_mouse.getXCoord() - Constants.ORIGIN), 2)
                                      + Math.pow((_mouse.getYCoord() - Constants.ORIGIN), 2));
                largeHypot = (((_scene.getWidth() - Constants.ORIGIN)/(_mouse.getXCoord() - Constants.ORIGIN)) * miniHypot);
                edgePoint = Math.sqrt(Math.pow(largeHypot, 2) - Math.pow((_scene.getWidth() - Constants.ORIGIN), 2));

                distance = (Math.sqrt(Math.pow((_scene.getWidth() - Constants.ORIGIN), 2) + Math.pow((edgePoint), 2)));

                translate =  
                        new TranslateTransition(Duration.millis(Constants.SHOT_RATE_CONSTANT * ((distance % Constants.SHOT_RATE_UPPER_BOUND) + Constants.SHOT_RATE_LOWER_BOUND)));  
                translate.setToX(_scene.getWidth() - Constants.ORIGIN); 
                translate.setToY(edgePoint);
            }
        }

        ArrayList<Transition> animations = new ArrayList<Transition>();
        animations.add(translate);

        this.setAnimations(animations);
    }

    //the shot made from an explosion also must calculate end points
    //takes which shot from the explosion this instance is, which
    //is what determines the end point the shot travels to, and which
    //kind of explosion it is a part of.
    public void initializeExplosion(int i, int indicator){

        TranslateTransition translate;

        translate = 
                new TranslateTransition(Duration.millis(5000)); 

        //if the cheat code was called, send the shot straight up
        if(indicator == Constants.EARTH_EXPLOSION_INDICATOR){

            if(i == Constants.TOP_MIDDLE){
                translate.setToX((0 - getX()) + (_scene.getWidth()/2));
                translate.setToY(0 - getY());
            }
        }
        else if(indicator == Constants.STAR_EXPLOSION_INDICATOR){
            if(i == Constants.TOP_MIDDLE){
                translate.setToX(0);
                translate.setToY(0 - getY());
            }
        }

        if(i == Constants.TOP_LEFT_CORNER){
            translate.setToX(0 - getX());
            translate.setToY((0 - getY()));
        }
        else if(i == Constants.TOP_RIGHT_CORNER){
            translate.setToX(_scene.getWidth() - getX());
            translate.setToY(0 - getY());
        }
        else if(i == Constants.BOTTOM_RIGHT_CORNER){
            translate.setToX(_scene.getWidth() - getX());
            translate.setToY(_scene.getHeight() - getY());
        }
        else if(i == Constants.BOTTOM_LEFT_CORNER){
            translate.setToX(0 - getX());
            translate.setToY(_scene.getHeight() - getY());
        }
        else if(i == Constants.RIGHT_MIDDLE){
            translate.setToX(_scene.getWidth() - getX());
            translate.setToY((0 - getY()) + (_scene.getHeight()/2));
        }
        else if(i == Constants.BOTTOM_MIDDLE){
            translate.setToX((_scene.getWidth() - getX()) - (_scene.getWidth()/2));
            translate.setToY((_scene.getHeight() - getY()));
        }
        else if(i == Constants.LEFT_MIDDLE){
            translate.setToX(0 - getX());
            translate.setToY((0 - getY()) + (_scene.getHeight()/2));
        }

        ArrayList<Transition> animations = new ArrayList<Transition>();
        animations.add(translate);

        this.setAnimations(animations);
    }

}
