package gamePackage;

import java.util.ArrayList;

import javafx.animation.Transition;
import javafx.animation.TranslateTransition;
import javafx.scene.Scene;
import javafx.util.Duration;

//This entire file is part of my masterpiece.
//Bailey Wall

/*
 * The shot looks like a fire emoji and is managed by
 * a shot manager, but can be created two different ways.
 */
public class Shot extends Sprite {

    private MouseCoords _mouse;
    private Scene _scene;

    //the constructor for a shot generated by the press of
    //a spacebar
    public Shot(MouseCoords mouse, Scene scene) {
        this((double) Constants.ORIGIN, (double) Constants.ORIGIN, scene);
        _mouse = mouse;
        initializeShot();
    }

    public Shot(double x, double y, Scene scene){ 
        setX(x);
        setY(y);
        setupShot(scene);
    }

    public void setupShot(Scene scene){
        setWidth(Constants.SHOT_WIDTH);
        setHeight(Constants.SHOT_HEIGHT);
        setFileName(Constants.SHOT_IMAGE);
        initializeImage();
        _scene = scene;
    }

    //for shots created with the space bar, trigonometry is
    //used to find the angle that the user's mouse was to the
    //origin and to extend the shot past the user's click to
    //the edge of the screen.
    private void initializeShot(){

        double miniHypot;
        double largeHypot;
        double edgePoint;
        double distance;
        TranslateTransition translate;

        //four different quadrants of the screen mean that the angles 
        //must be processed four different ways, and that the 
        //transitions must be added to the shots in four different ways.
        //the algebra is different in each if statement; the first is 
        //commented as an example

        //if the click was on the left of Earth
        if(_mouse.getXCoord() < Constants.ORIGIN){
            //if the click was above Earth
            if(_mouse.getYCoord() <= Constants.ORIGIN){
                //get the distance of the mini hypoteneuse made with the click
                miniHypot = Math.sqrt(Math.pow((Constants.ORIGIN - _mouse.getXCoord()), 2)
                                      + Math.pow((Constants.ORIGIN - _mouse.getYCoord()), 2));
                //extend that distance to the edge of the screen
                largeHypot = ((Constants.ORIGIN/(Constants.ORIGIN - _mouse.getXCoord())) * miniHypot);
                //calculate the y point based on that distance
                edgePoint = Math.sqrt(Math.pow(largeHypot, 2) - Math.pow(Constants.ORIGIN, 2));

                //get the distance between the new point and the origin
                distance = (Math.sqrt(Math.pow(-Constants.ORIGIN, 2) + Math.pow((-edgePoint), 2)));

                //create a translation with a constant rate for almost all angles
                translate =  
                        new TranslateTransition(Duration.millis(Constants.SHOT_RATE_CONSTANT * ((distance % Constants.SHOT_RATE_UPPER_BOUND) + Constants.SHOT_RATE_LOWER_BOUND))); 
                //send the shot all the way to the left
                translate.setToX(-Constants.ORIGIN); 
                //send the shot up to the right point
                translate.setToY(-edgePoint);
            }
            else{
                miniHypot = Math.sqrt(Math.pow((Constants.ORIGIN - _mouse.getXCoord()), 2)
                                      + Math.pow((_mouse.getYCoord() - Constants.ORIGIN), 2));
                largeHypot = ((Constants.ORIGIN/(Constants.ORIGIN - _mouse.getXCoord())) * miniHypot);
                edgePoint = Math.sqrt(Math.pow(largeHypot, 2) - Math.pow(Constants.ORIGIN, 2));

                distance = (Math.sqrt(Math.pow(-Constants.ORIGIN, 2) + Math.pow((edgePoint), 2)));

                translate =  
                        new TranslateTransition(Duration.millis(Constants.SHOT_RATE_CONSTANT * ((distance % Constants.SHOT_RATE_UPPER_BOUND) + Constants.SHOT_RATE_LOWER_BOUND))); 
                translate.setToX(-Constants.ORIGIN); 
                translate.setToY(edgePoint);
            }
        }
        else if(_mouse.getXCoord() > Constants.ORIGIN){
            if(_mouse.getYCoord() <= Constants.ORIGIN){
                miniHypot = Math.sqrt(Math.pow((_mouse.getXCoord() - Constants.ORIGIN), 2)
                                      + Math.pow((Constants.ORIGIN - _mouse.getYCoord()), 2));
                largeHypot = (((_scene.getWidth() - Constants.ORIGIN)/(_mouse.getXCoord() - Constants.ORIGIN)) * miniHypot);
                edgePoint = Math.sqrt(Math.pow(largeHypot, 2) - Math.pow((_scene.getWidth() - Constants.ORIGIN), 2));

                distance = (Math.sqrt(Math.pow((_scene.getWidth() - Constants.ORIGIN), 2) + Math.pow((-edgePoint), 2)));

                translate =  
                        new TranslateTransition(Duration.millis(Constants.SHOT_RATE_CONSTANT * ((distance % Constants.SHOT_RATE_UPPER_BOUND) + Constants.SHOT_RATE_LOWER_BOUND)));  
                translate.setToX(_scene.getWidth() - Constants.ORIGIN); 
                translate.setToY(-edgePoint);
            }
            else{
                miniHypot = Math.sqrt(Math.pow((_mouse.getXCoord() - Constants.ORIGIN), 2)
                                      + Math.pow((_mouse.getYCoord() - Constants.ORIGIN), 2));
                largeHypot = (((_scene.getWidth() - Constants.ORIGIN)/(_mouse.getXCoord() - Constants.ORIGIN)) * miniHypot);
                edgePoint = Math.sqrt(Math.pow(largeHypot, 2) - Math.pow((_scene.getWidth() - Constants.ORIGIN), 2));

                distance = (Math.sqrt(Math.pow((_scene.getWidth() - Constants.ORIGIN), 2) + Math.pow((edgePoint), 2)));

                translate =  
                        new TranslateTransition(Duration.millis(Constants.SHOT_RATE_CONSTANT * ((distance % Constants.SHOT_RATE_UPPER_BOUND) + Constants.SHOT_RATE_LOWER_BOUND)));  
                translate.setToX(_scene.getWidth() - Constants.ORIGIN); 
                translate.setToY(edgePoint);
            }
        }
        //the case if the X coordinate of the mouse is equal to the origin
        //prevents a divide by zero error by substituting in a fake edgepoint calculation
        else{
            if(_mouse.getYCoord() <= Constants.ORIGIN){
                edgePoint = Math.sqrt(Math.pow(Constants.DIVIDE_BY_ZERO_CATCH, 2) - Math.pow(Constants.ORIGIN, 2));

                distance = (Math.sqrt(Math.pow(-Constants.ORIGIN, 2) + Math.pow((edgePoint), 2)));

                translate =  
                        new TranslateTransition(Duration.millis(Constants.SHOT_RATE_CONSTANT * ((distance % Constants.SHOT_RATE_UPPER_BOUND) + Constants.SHOT_RATE_LOWER_BOUND))); 
                translate.setToX(-Constants.ORIGIN); 
                translate.setToY(-edgePoint);
            }
            else{
                edgePoint = Math.sqrt(Math.pow(Constants.DIVIDE_BY_ZERO_CATCH, 2) - Math.pow(Constants.ORIGIN, 2));

                distance = (Math.sqrt(Math.pow(-Constants.ORIGIN, 2) + Math.pow((edgePoint), 2)));

                translate =  
                        new TranslateTransition(Duration.millis(Constants.SHOT_RATE_CONSTANT * ((distance % Constants.SHOT_RATE_UPPER_BOUND) + Constants.SHOT_RATE_LOWER_BOUND))); 
                translate.setToX(-Constants.ORIGIN); 
                translate.setToY(edgePoint);
            }
        }

        ArrayList<Transition> animations = new ArrayList<Transition>();
        animations.add(translate);

        this.setAnimations(animations);
    }

    public Scene getScene(){
        return _scene;
    }

}
