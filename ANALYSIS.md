#Game 1 Analysis

Author: Bailey Wall

##Project Journal

###Time Review
	I worked on this project for about 30 hours from the day I started on August 25 until the day I turned it in on September 4. Most of my time was spent designing and coding new features and refactoring, and I spent several hours reading about how to create games in JavaFX. I worked on and tested my code on my local machine for a variable amount of time before I pushed it to my GitHub repository. The most difficult task for me was not the most time consuming, but one of the most important; I struggled with coming up with what game I wanted to make. Once I determined what I was going to create it was relatively easy to put my ideas into code and make them work, but I struggled to come up with a concept I was excited about. I spent a significant amount of time refactoring as I went along, which was frustrating at the beginning because I felt like I had so many features left to implement, but this actually ended up being really helpful; once I had refactored my code adding those new features was so much easier. I spent a lot of time finding a font and sound effects I wanted to use in my game and which I felt made the game more fun to play, but I was concerned that the program would not be able to find the files and cause the game not to run. So I decided to delete about three hours worth of work from my program before turning it in to ensure that it would run without any bugs.

###Commits
	I committed code for two consecutive days, then did not commit any for four days, then committed code again for three consecutive days. Of the eleven commits I made, six were to push new code (the other five were to help build my understanding of GitHub). My initial commit was about 350 lines of code; the next commit I added about 225 lines. On the third commit, which I waited about four days to make, I added around 1500 lines of code. I committed again after I refactored to get rid of all constants and public instance variables, and lastly again to remove audio and font for the last commit. The average size of these commits was about 700 lines. I feel that all of my commit messages describe the development of the major features of my project, but they are not detailed enough to tell the whole story. Additionally, the commits did not happen every time something important did; they happened when I felt like backing up my progress.
	I made the commit titled, “added star and boss level, graphics, and one cheat” on September 2. I had not made a commit in four days and had added images, two levels, several features that came along with those levels, and one cheat. I packaged these changes as a commit because they were important updates to both the gameplay and user interface of the project. The size of the commit, however, was about 1500 lines and so would not have been reasonable for someone else to review.
	The commit titled “got rid of public instance vars, added constants” was made on September 3. The purpose of this commit was to push a refactoring I had done which made the public instance variables private and made magic numbers into constants.  These changes were packaged as a commit both because it was a completed refactoring and because I wasn’t going to work on the project any more that day. There were around 190 real additions and 135 deletions in that commit, which I think is a reasonably size for someone else to review before adding it to the repository.

###Conclusions
	I was pretty correct about the size of this project, though the additional guidelines (no public instance variables and no hard-coded numbers) introduced later on in the project ended up taking a decent amount of time to integrate, which was unexpected. Now that I know such specific guidelines exist, I will be more inclined to do everything I can as soon as I can do it knowing that the guidelines and expectations really will evolve in the middle of the project. The parts of my code that required the most editing were the different classes which made up the levels. I kept changing which functionality I wanted in which classes, and so needed to move instance variables and methods up to higher levels of the hierarchy so more classes could access them. To be a better designer I should start being more intentional with my commits and pushing to the repository whenever I have added a new feature. It is also important to continue to refactor as I code, in order to make it easier to add new features and characters and to keep the code’s organization clear. If I could work on and improve one aspect of my project right now it would be to research how to safely include font and sound files in a Java program; I thought they added a lot to my game and would really like to reimplement them. 

##Design Review

###Status
	I believe the code is relatively consistent in layout, naming conventions and descriptiveness, and style. There are no abbreviations used in naming, and classes which have similar functions in the game have similar names. Most of the code is clear and easy to understand with short functions that do one job, but some (especially the blocks that implement geometric algorithms and those that do calculations with formulas that are almost the same) require commenting to explain what they are doing. If I understand back channels correctly, my code uses them extensively because it uses inheritance and abstraction extensively. Most parameters passed in the creation of my characters have to do with their placement on the screen; almost everything else is accessed through getters and setters.
	The first piece of code I will describe in detail is the getRandomXY(int identity) method found on lines 92-178 of the Mode class. This code returns two randomly generated numbers in the form of an array, but it must return two different types of numbers for the two different purposes that these random numbers are needed for. One is for the AlienMode and StarMode classes which need two random numbers to create a coordinate outside the screen that an Alien can be created at and can move into the game screen from, and the other is for the StarMode and BossMode classes which need two random numbers to create a coordinate inside the screen to either make a Star appear or to teleport the Boss to. This dual functionality requires an identifier constant parameter in order to decide which situation the numbers are being generated for, and code which looks duplicated but which actually applies different bounds to the same calls for random numbers. This code could be improved by splitting it into two different functions, potentially which are called based on the constant identifier from the same facilitator function getRandomXY(int identity), because the two different procedures completed based on the constant identifier parameter do not interact with each other at all.
	The second piece of code I will describe is the cleanupShapes() function found on lines 83-95 of the Level class. This code is part of the game loop executed 60 times every second and serves to clear the shots which have traveled to the edge of the board from the screen. It is good code because this is a function which each extension of the Level class (Screen and all of the extensions of Mode) uses, and its implementation in Level keeps each class farther down the design hierarchy from having to define it.

###Design
	The program starts in a GameLoop which holds, initializes, and starts the game loop of AlienWorld. This class extends Base, which is the class that holds the game loop framework as well as the title and frames per second, and implements the game loop methods. AlienWorld is the class which runs whenever the game is executing. It holds the current level and screen of the game and calls the corresponding game loop methods of the active level. AlienWorld first initializes the first of the screens of the game, an extension of the Level class called Screen, and waits for the user to press enter to change out the active Level and initialize the first instance of gameplay, which is an extension of the Level and Mode classes called AlienMode. After the player wins this first level, AlienWorld again activates a screen to wait until the player indicates they are ready to start the second level, which is an extension of the AlienMode class, called StarMode. Once the player wins this second level yet another screen is initialized by AlienWorld to wait until the player indicates that they are ready to start the next level. This final level, called BossMode, is an extension of StarMode, and once the player beats it AlienWorld initializes a final screen which congratulates the player on their victory and asks him or her whether he or she wants to exit or play again. If the player at any point loses, which is monitored and recognized again by AlienWorld, a special screen is initialized and prompts the player to press one key to exit or another to try again.
	Each of the extensions of Level (including Screen) held by AlienWorld contain an earth capable of shooting, and each of the extensions of Mode also hold active aliens. StarMode holds all of these things plus active stars, and BossMode holds everything that StarMode does plus a Boss.
	To add a new level to the game one would either extend the Mode class or one of these other classes that extend the Mode class: AlienMode, StarMode, or BossMode. If the person extending the game wants to start with nothing but a shooting earth then they should do the former process and extend Level, but if they want to start from another framework, one that creates aliens at a certain time interval for instance, they should extend AlienMode. To extend the Mode class one must only define an updateShapes function, and to extend one of the existing extensions of the Mode class while keeping some functionality it is easiest to override one of the three methods defined in the game loop and then call the same method on the super.
	My code is designed the way it is because I wanted to have a shooting Earth on the screen at all times; the way this is implemented means that to create any level without a shooting earth would require refactoring and likely reorganization of the program. I don’t like that this is how the program is set up, but it seemed to me and still seems like the best way to get the functionality I want from each level in the clearest way possible.
	Losing and winning conditions are implemented by using the AlienWorld class, which controls the game flow, to check boolean or integer values held in the AlienMode, StarMode, and BossMode classes during each iteration of the game loop. Because the game loop runs through the AlienWorld class, which in turn calls the game loop functions of the currently active level, it is ensured that AlienWorld is always caught up with the current status of the level. This allows the class to correctly and consistently watch for the losing or winning conditions to be met and control the game in reaction as is necessary.
	Another specification met is that there exist characters that both move around the gameplay area and interact with the player. These two responsibilities of character monitoring are actually split up to be handled in two different ways: the movement of each individual character is controlled by the character itself while the interaction of any of these characters is controlled by the Mode implementation, or active level. For example, the Alien character upon construction calculates a random speed value and assigns it to its own transition towards Earth, which each Alien then itself starts. Yet each Alien is not responsible for monitoring its own intersections with other characters and life cycle; by iterating through each instance of active Aliens and checking their positions against those of the active Shots and of Earth, the Mode class monitor the characters during the execution of the game loop and remove them when necessary. The same can be said of the Shot class; it manages its own movement but its lifecycle is controlled by the level which it lives in.

###Alternate Designs
	One design decision I made was to extend StarMode from AlienMode, and then to extend BossMode from StarMode. I wanted to inherit all of the features I had implemented in AlienMode into StarMode, so extending the former into the latter made total sense. Yet I only wanted the star creation functionality from StarMode without the random Alien generation in BossMode, which made the second decision significantly more difficult. I considered extending StarMode from Mode and then extending both AlienMode and BossMode from it, but I decided to extend BossMode from StarMode from AlienMode instead because it made organizational sense to extend the next level from the former, and because I would have had to suppress both the random alien generation in BossMode and the star generation in AlienMode. Thus the simplest thing to do was simply to block the random generation of Aliens in BossMode.
	Another design decision I made was to extend both the Screen class and the Mode class from the Level class. There are several reasons that this was a good implementation of these classes, the first of which is that it makes it easy for AlienWorld to switch between gameplay and instructional screens simply by switching implementations of the Level class. I considered making these two classes, the Scene and the Mode classes, separately from scratch because their functionality is pretty basically different, but the need to be able to switch them in and out showed that they had to have some sort of common implementation.
	One of the most important bugs that remains in this project’s implementation is the calculation of the speed of the shot when it is sent close to a 90º or 270º angle from the line extending from the left side of the screen to Earth. The calculation of the angle of the click involves splitting the screen into four quadrants and determining the point at the left or right edge of the screen to send the shot to using right triangles, and ideally the rate at which the shot travels would be determined by the distance it has to travel, making it consistent for all distances. However, the time and distance it takes for a shot traveling straight across to the left of the screen is smaller and shorter than it takes a shot traveling 10,000 pixels down the screen along a giant hypotenuse. So when calculated this way, the rate for the latter shot to move across the screen is smaller than that of the former. To remedy this I attempted to raise the speed of these shots which were traveling much slower than the others, but in so doing made them faster than those that have a normal distance range. This speed rarely but in some cases causes aliens which should have been removed from the screen upon a collision to be skipped over, not removing them from the game. If this happens the player needs only to hit the alien again.
	Another bug…
	And yet another bug…

##Code Masterpiece

	The Shot class and its Explosion extension is my example of good code. A Shot is what is created when the user presses the space key, and an explosion is what happens when a Star is hit or when the player presses the “W” key, creating a set number of Explosions. Explosions and Shots do the same thing; they travel across the screen and if the level detects that they have hit an Alien or the Boss, they cause damage to that character and disappear. This makes it convenient to store them together in order to be able to iterate over them. Yet they are created in different ways. Shots get their direction from the position of the mouse at the time of their creation and start from Earth, and Explosions have pre-set directions in which to travel and can be launched either from Earth or a Star, which can be located anywhere. The best way to implement this type of object in code is by defining one in a class and extending that class to define the other one; thus the objects can be stored together and iterated over but have slightly different attributes. This also allows for different constructors which create the same basic type of object but can take in and supply different parameters as needed. It is best to keep both the Earth and the Star explosions in the same class because it is easy to differentiate between them using just a number as an identifier, and the differences between their functions are quite small.